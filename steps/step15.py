"""복잡한 계산 그래프 (이론 편)

역전파 함수 호출 순서
    1. 스택 사용 (현재 방식)
        funcs 리스트를 스택처럼 사용해, 마지막에 추가된 함수를 먼저 pop하고 있다. (LIFO)
        이러면 복잡한 계산 그래프 (예를 들어 중간에 분기했다 다시 합류하는 등)에서 역전파 순서가 꼬일 수 있다.

    2. generation(세대) 기록 방식                                                                       #추천     
        각 Function과 Variable에 generation 값을 기록한다.
        Variable이 만들어질 때, 자신의 creator(함수)의 generation보다 1 크게 설정한다.
        funcs 리스트에 함수를 추가할 때, genration이 큰 함수 (=출력에 가까운 함수)부터 pop하도록 정렬해서 처리한다.
        (실제 PyTorch 등 프레임워크에서 널리 사용하는 방식)

    2+. 우선순위큐(heapq)를 사용하여 generation 순서대로 역전파 호출하기                                #심화
        heapq는 자동으로 가장 큰 (또는 작은) generation 값을 가진 Function을 빠르게 pop할 수 있다.
        funcs 리스트가 매우 커질 때, 매번 전체 정렬하는 것보다 효율적이다.
        실제로 정렬 방식은 funcs에 함수를 추가할 때마다 전체를 정렬하여 O(N logN)이 들지만,
        heapq를 사용할 시 함수 추가/꺼내기 할때마다 O(logN)이 소요된다.
        따라서 매우 깊거나 복잡한 계산 그래프에서는 heapq가 더 빠르고 메모리 효율적이다.

    3. 위상정렬(topological sort)방식은?
        위상정렬: DAG(방향 있는 비순환 그래프)에서, 모든 연산을 "선행 노드가 먼저 처리되도록" 일렬로 정렬하는 알고리즘이다.  계산 그래프 전체를 한 번에 정렬해서 역전파 순서를 완벽하게 보장하는 방식이라 실시간성, 메모리 측면에서는 불리할 수 있다고 한다. 
        TensorFlow(정적 그래프) 등에선 많이 사용하지만, 동적 그래프(Chainer, PyTorch 등)에서는 generation 방법을 선호한다.

"""